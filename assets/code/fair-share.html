<!DOCTYPE html>
<title>Solution Concepts</title>
<style>
	.lil-gui{
		--font-family:monospace;
	}
	html {
		font-family: monospace;
	}
	body {
		margin: 0;

	}
</style>

<script type="module">
	import * as THREE from 'https://cdn.skypack.dev/three'
	import { OrbitControls } from 'https://cdn.skypack.dev/three/examples/jsm/controls/OrbitControls.js';
	import { GUI } from 'https://cdn.skypack.dev/three/examples/jsm/libs/lil-gui.module.min.js';

	const params = {
		'v(X)': 0.1,
		'v(Y)': 0.1,
		'v(Z)': 0.1,
		'v(XY)': 0.5,
		'v(XZ)': 0.5,
		'v(YZ)': 0.667,
		'v(N)': 1,
		'Banzhaf value': true,
		'Shapley value': true,
	}

	function make_scene() {
		const scene = new THREE.Scene();
		scene.background = new THREE.Color(0x333344);

		const indv = [
			new THREE.Plane(new THREE.Vector3(1, 0, 0), -0.1),
			new THREE.Plane(new THREE.Vector3(0, 1, 0), -0.1),
			new THREE.Plane(new THREE.Vector3(0, 0, 1), -0.1)
		];
		const coal = [
			new THREE.Plane(new THREE.Vector3(1, 1, 0), -0.25),
			new THREE.Plane(new THREE.Vector3(1, 0, 1), -0.25),
			new THREE.Plane(new THREE.Vector3(0, 1, 1), -0.667/2)
		];

		const geometry = new THREE.BufferGeometry();
		const verts = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
		geometry.setAttribute('position', new THREE.BufferAttribute(verts, 3))

		const material_cor = new THREE.MeshBasicMaterial({ color: "#ffa", opacity: 0.6, clippingPlanes: [...coal, ...indv], transparent: true, side: THREE.DoubleSide });
		const material_imp = new THREE.MeshBasicMaterial({ color: "#9CB1FF", opacity: 0.3, clippingPlanes: indv, transparent: true, side: THREE.DoubleSide });
		const material_pre = new THREE.MeshBasicMaterial({ color: "#ffa", wireframe: true });

		const mesh_cor = new THREE.Mesh(geometry, material_cor);
		const mesh_imp = new THREE.Mesh(geometry, material_imp);
		const mesh_pre = new THREE.Mesh(geometry, material_pre);
		scene.add(mesh_cor);
		scene.add(mesh_imp);
		scene.add(mesh_pre);

		const axesHelper = new THREE.AxesHelper(2);
		axesHelper.setColors('#FF9CB2', '#B1FF9C', '#9CB1FF')
		scene.add(axesHelper);

		var dotGeometry = new THREE.BufferGeometry();
		const dotVerts = new Float32Array([0, 0, 0]);
		dotGeometry.setAttribute('position', new THREE.BufferAttribute(dotVerts, 3))
		var dotMaterial = new THREE.PointsMaterial({ color: "#fff", size: 10, sizeAttenuation: false });
		var bazMaterial = new THREE.PointsMaterial({ color: "#000", size: 9, sizeAttenuation: false });
		var sha = new THREE.Points(dotGeometry, dotMaterial);
		var baz = new THREE.Points(dotGeometry, bazMaterial);
		scene.add(sha);
		scene.add(baz);

		const shap = () => {
			const v0 = 0;
			const v1 = -indv[0].constant;
			const v2 = -indv[1].constant;
			const v3 = -indv[2].constant;
			const v12 = -coal[0].constant * 2;
			const v13 = -coal[1].constant * 2;
			const v23 = -coal[2].constant * 2;
			const vN = mesh_pre.scale.x;

			// 			123			132			213			231			312			321
			const x1 = v1 - v0 + v1 - v0 + v12 - v2 + vN - v23 + v13 - v3 + vN - v23
			const x2 = v12 - v1 + vN - v13 + v2 - v0 + v2 - v0 + vN - v13 + v23 - v3
			const x3 = vN - v12 + v13 - v1 + vN - v12 + v23 - v2 + v3 - v0 + v3 - v0

			sha.position.set(x1 / 6, x2 / 6, x3 / 6);

			const b1 = vN - v23 + v12 -v2 + v13 - v3 + v1 - v0
			const b2 = vN - v13 + v12 -v1 + v23 - v3 + v2 - v0
			const b3 = vN - v12 + v13 -v1 + v23 - v2 + v3 - v0

			const nrm = 4;//b1 + b2 + b3;
			baz.position.set(b1 / nrm, b2 / nrm, b3 / nrm);
		}

		const gui = new GUI({touchStyles: true});
		gui.domElement.classList.add( 'force-touch-styles' );
		gui.close();
		const vs = gui.addFolder( 'Values' );
		vs.add(params, 'v(X)').min(0).max(1).onChange(d => { indv[0].constant = -d; shap(); });
		vs.add(params, 'v(Y)').min(0).max(1).onChange(d => { indv[1].constant = -d; shap(); });
		vs.add(params, 'v(Z)').min(0).max(1).onChange(d => { indv[2].constant = -d; shap(); });
		vs.add(params, 'v(XY)').min(0).max(1).onChange(d => { coal[0].constant = -d * 0.5; shap(); });
		vs.add(params, 'v(XZ)').min(0).max(1).onChange(d => { coal[1].constant = -d * 0.5; shap(); });
		vs.add(params, 'v(YZ)').min(0).max(1).onChange(d => { coal[2].constant = -d * 0.5; shap(); });
		const total = gui.addFolder( 'Total' );
		total.close();
		total.add(params, 'v(N)').min(0).max(2).onChange(d => { mesh_cor.scale.set(d,d,d); mesh_pre.scale.set(d,d,d); mesh_imp.scale.set(d,d,d); shap(); });
		const visibility = gui.addFolder( 'Visibility' );
		visibility.add(params, 'Banzhaf value').onChange(d => { baz.visible = d; });
		visibility.add(params, 'Shapley value').onChange(d => { sha.visible = d; });


		const xlinverts = new Float32Array([0,0,0, 1,1,0, 0.5,0.5,0, 1,0,0, 0,1,0]);
		const ylinverts = new Float32Array([0.5,0,0, 0.5,0.5,0,1,1,0, 0.5,0.5,0, 0,1,0]);
		const zlinverts = new Float32Array([1,0,0, 0,0,0, 1,1,0, 0,1,0]);
		const xlin  = new THREE.BufferGeometry();
		const ylin  = new THREE.BufferGeometry();
		const zlin  = new THREE.BufferGeometry();
		xlin.setAttribute('position', new THREE.BufferAttribute(xlinverts, 3))
		ylin.setAttribute('position', new THREE.BufferAttribute(ylinverts, 3))
		zlin.setAttribute('position', new THREE.BufferAttribute(zlinverts, 3))
		var xlines = new THREE.Line(xlin, new THREE.LineBasicMaterial({color: '#FF9CB2'}));
		var ylines = new THREE.Line(ylin, new THREE.LineBasicMaterial({color: '#B1FF9C'}));
		var zlines = new THREE.Line(zlin, new THREE.LineBasicMaterial({color: '#9CB1FF'}));
		xlines.position.set(1.05,0.05,0);
		ylines.position.set(0,1.05,0.15);
		zlines.position.set(0,0.05,1.15);
		xlines.rotation.set(0,0,0);
		ylines.rotation.set(0,Math.PI*2/4,0);
		zlines.rotation.set(0,Math.PI*2/4,0);
		xlines.scale.set(0.1, 0.1, 0.1);
		ylines.scale.set(0.1, 0.1, 0.1);
		zlines.scale.set(0.1, 0.1, 0.1);
		scene.add(xlines)
		scene.add(ylines)
		scene.add(zlines)

		shap();
		return scene;
	}


	function make_camera(ratio) {
		const camera = new THREE.PerspectiveCamera(70, ratio, 0.01, 10);
		camera.position.set(2, 1, 1);

		return camera;
	}

	function make_renderer(scene, camera) {
		const renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setAnimationLoop(() => { renderer.render(scene, camera) });
		renderer.localClippingEnabled = true;

		const controls = new OrbitControls(camera, renderer.domElement);

		return renderer;
	}

	const scene = make_scene();
	const camera = make_camera(window.innerWidth / window.innerHeight);
	const renderer = make_renderer(scene, camera);

	document.body.appendChild(renderer.domElement);

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	window.addEventListener('resize', onWindowResize);


</script>