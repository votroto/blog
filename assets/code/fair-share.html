<!DOCTYPE html>
<title>Solution Concepts</title>
<style>
	.lil-gui{
		--font-family: monospace;
	}
	html {
		font-family: monospace;
	}
	body {
		margin: 0;

	}
</style>

<script type="module">
	import * as THREE from 'https://cdn.skypack.dev/three'
	import { OrbitControls } from 'https://cdn.skypack.dev/three/examples/jsm/controls/OrbitControls.js';
	import { GUI } from 'https://cdn.skypack.dev/three/examples/jsm/libs/lil-gui.module.min.js';

const ToonShaderHatching = {
  uniforms: {
    uBaseColor: {value: new THREE.Color(0x333344)},
    uLineColor: {value: new THREE.Color('#B1FF9C')}
  },
  vertexShader: `
		varying vec3 vpos;

		void main() {
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			vpos = position;
		}`,
  fragmentShader: `
		uniform vec3 uBaseColor;
		uniform vec3 uLineColor;
		varying vec3 vpos;

		void main() {
			float opa = 1.0-length(vpos);
			if (mod(vpos.x + 2.0 * vpos.y, .05) <= 0.01) {
				gl_FragColor = vec4(uLineColor, 0.8*opa);
			}
			else{
				gl_FragColor = vec4(uBaseColor, 0.);
			}
		}`
};
	const params = {
		'v(X)': 0.1,
		'v(Y)': 0.1,
		'v(Z)': 0.1,
		'v(XY)': 0.5,
		'v(XZ)': 0.5,
		'v(YZ)': 2/3,
		'v(N)': 1,
		'Banzhaf value': true,
		'Shapley value': true,
	}

	function createShaderMaterial( shader ) {
		const u = THREE.UniformsUtils.clone( shader.uniforms );
		const vs = shader.vertexShader;
		const fs = shader.fragmentShader;

		const material = new THREE.ShaderMaterial( { uniforms: u, vertexShader: vs, fragmentShader: fs , transparent: true, side: THREE.DoubleSide} );

		return material;
	}

	function make_scene() {
		const scene = new THREE.Scene();
		scene.background = new THREE.Color(0x333344);

		const indv = [
			new THREE.Plane(new THREE.Vector3(1, 0, 0), -0.1),
			new THREE.Plane(new THREE.Vector3(0, 1, 0), -0.1),
			new THREE.Plane(new THREE.Vector3(0, 0, 1), -0.1)
		];
		const coal = [
			new THREE.Plane(new THREE.Vector3(0.5, 0.5, 0), -0.5),
			new THREE.Plane(new THREE.Vector3(0.5, 0, 0.5), -0.5),
			new THREE.Plane(new THREE.Vector3(0, 0.5, 0.5), -2/3)
		];

		const pgeometry = new THREE.BufferGeometry();
		const pverts = new Float32Array([2-0.01, -0.5, -0.5,-0.5, 2-0.01, -0.5, -0.5, -0.5, 2-0.01]);
		pgeometry.setAttribute('position', new THREE.BufferAttribute(pverts, 3))


		const geometry = new THREE.BufferGeometry();
		const verts = new Float32Array([1, 0,0,0, 1, 0,0,0, 1]);
		geometry.setAttribute('position', new THREE.BufferAttribute(verts, 3))

		const hatchingMaterial = createShaderMaterial( ToonShaderHatching );

		const material_cor = new THREE.MeshBasicMaterial({ color: "#ffa", opacity: 0.6, clippingPlanes: [...coal, ...indv], transparent: true, side: THREE.DoubleSide });
		const material_imp = new THREE.MeshBasicMaterial({ color: "#9CB1FF", opacity: 0.3, clippingPlanes: indv, transparent: true, side: THREE.DoubleSide });
		const material_pre = new THREE.MeshBasicMaterial({ color: "#B1FF9C", opacity: 0.4, transparent:true, wireframe: true });

		const mesh_cor = new THREE.Mesh(geometry, material_cor);
		const mesh_imp = new THREE.Mesh(geometry, material_imp);
		const mesh_pre = new THREE.Mesh(pgeometry, hatchingMaterial);
		const mesh_preglow = new THREE.Mesh(geometry, material_pre);
		scene.add(mesh_pre);
		scene.add(mesh_cor);
		scene.add(mesh_imp);
		scene.add(mesh_preglow);

		var dotGeometry = new THREE.BufferGeometry();
		const dotVerts = new Float32Array([0, 0, 0]);
		dotGeometry.setAttribute('position', new THREE.BufferAttribute(dotVerts, 3))
		var dotMaterial = new THREE.PointsMaterial({ color: "#fff", size: 10, sizeAttenuation: false });
		var bazMaterial = new THREE.PointsMaterial({ color: "#000", size: 9, sizeAttenuation: false });
		var sha = new THREE.Points(dotGeometry, dotMaterial);
		var baz = new THREE.Points(dotGeometry, bazMaterial);
		scene.add(sha);
		scene.add(baz);

		const shap = () => {
			const v1 = -indv[0].constant;
			const v2 = -indv[1].constant;
			const v3 = -indv[2].constant;
			const v12 = -coal[0].constant;
			const v13 = -coal[1].constant;
			const v23 = -coal[2].constant;
			const vN = mesh_pre.scale.x;

			const x1 = +2*v1 - v2 - v3 + v12 + v13 - 2*v23 + 2*vN
			const x2 = -v1 + 2*v2 - v3 + v12 - 2*v13 + v23 + 2*vN
			const x3 = -v1 - v2 + 2*v3 - 2*v12 + v13 + v23 + 2*vN

			sha.position.set(x1 / 6, x2 / 6, x3 / 6);

			const b1 = vN - v23 + v12 - v2 + v13 - v3 + v1
			const b2 = vN - v13 + v12 - v1 + v23 - v3 + v2
			const b3 = vN - v12 + v13 - v1 + v23 - v2 + v3

			baz.position.set(b1 / 4, b2 / 4, b3 / 4);
		}

		const gui = new GUI({touchStyles: true});

		const folder_val = gui.addFolder( 'Values' );
		const folder_tot = gui.addFolder( 'Total' );
		const folder_vis = gui.addFolder( 'Visibility' );

		folder_val.add(params, 'v(X)').min(0).max(1).onChange(d => { indv[0].constant = -d; shap(); });
		folder_val.add(params, 'v(Y)').min(0).max(1).onChange(d => { indv[1].constant = -d; shap(); });
		folder_val.add(params, 'v(Z)').min(0).max(1).onChange(d => { indv[2].constant = -d; shap(); });
		folder_val.add(params, 'v(XY)').min(0).max(1).onChange(d => { coal[0].constant = -d; shap(); });
		folder_val.add(params, 'v(XZ)').min(0).max(1).onChange(d => { coal[1].constant = -d; shap(); });
		folder_tot.add(params, 'v(N)').min(0).max(2).onChange(d => { mesh_cor.scale.set(d,d,d); mesh_pre.scale.set(d,d,d); mesh_imp.scale.set(d,d,d); mesh_preglow.scale.set(d,d,d); shap(); });
		folder_val.add(params, 'v(YZ)').min(0).max(1).onChange(d => { coal[2].constant = -d; shap(); });
		folder_vis.add(params, 'Banzhaf value').onChange(d => { baz.visible = d; });
		folder_vis.add(params, 'Shapley value').onChange(d => { sha.visible = d; });

		gui.domElement.classList.add( 'force-touch-styles' );
		folder_tot.close();
		gui.close();

		const axesHelper = new THREE.AxesHelper(2);
		axesHelper.setColors('#FF9CB2', '#B1FF9C', '#9CB1FF')
		scene.add(axesHelper);

		const xlinverts = new Float32Array([0,0,0, 1,1,0, 0.5,0.5,0, 1,0,0, 0,1,0]);
		const ylinverts = new Float32Array([0.5,0,0, 0.5,0.5,0, 1,1,0, 0.5,0.5,0, 0,1,0]);
		const zlinverts = new Float32Array([1,0,0, 0,0,0, 1,1,0, 0,1,0]);
		const xlin  = new THREE.BufferGeometry();
		const ylin  = new THREE.BufferGeometry();
		const zlin  = new THREE.BufferGeometry();
		xlin.setAttribute('position', new THREE.BufferAttribute(xlinverts, 3))
		ylin.setAttribute('position', new THREE.BufferAttribute(ylinverts, 3))
		zlin.setAttribute('position', new THREE.BufferAttribute(zlinverts, 3))
		var xlines = new THREE.Line(xlin, new THREE.LineBasicMaterial({color: '#FF9CB2'}));
		var ylines = new THREE.Line(ylin, new THREE.LineBasicMaterial({color: '#B1FF9C'}));
		var zlines = new THREE.Line(zlin, new THREE.LineBasicMaterial({color: '#9CB1FF'}));
		xlines.position.set(1.05,0.05,0);
		ylines.position.set(0,1.05,0.15);
		zlines.position.set(0,0.05,1.15);
		xlines.rotation.set(0,0,0);
		ylines.rotation.set(0,Math.PI/2,0);
		zlines.rotation.set(0,Math.PI/2,0);
		xlines.scale.set(0.1, 0.1, 0.1);
		ylines.scale.set(0.1, 0.1, 0.1);
		zlines.scale.set(0.1, 0.1, 0.1);
		scene.add(xlines)
		scene.add(ylines)
		scene.add(zlines)

		shap();
		return scene;
	}

	function make_camera(ratio) {
		const camera = new THREE.PerspectiveCamera(70, ratio, 0.01, 10);
		camera.position.set(2, 1, 1);

		return camera;
	}

	function make_renderer(scene, camera) {
		const renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setAnimationLoop(() => { renderer.render(scene, camera) });
		renderer.localClippingEnabled = true;

		const controls = new OrbitControls(camera, renderer.domElement);

		return renderer;
	}

	const scene = make_scene();
	const camera = make_camera(window.innerWidth / window.innerHeight);
	const renderer = make_renderer(scene, camera);

	document.body.appendChild(renderer.domElement);

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	window.addEventListener('resize', onWindowResize);
</script>